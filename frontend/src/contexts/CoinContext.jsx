import { createContext, useContext, useEffect, useRef, useState } from 'react'
import toast from 'react-hot-toast'
















import { useWebsiteAuth } from './WebsiteAuthContext'















import { coinAPI } from '../services/api'































/**















 * CRCRCoin嚗??其?鞈港撩?嚗?















 * - ????敺撩???嚗?雿輻 localStorage 敹怠?















 * - ?舀憭???閬??? BroadcastChannel ?郊















 */































const CoinContext = createContext(null)































const DEFAULT_WALLET = {















  balance: 0,















  lastClaimAt: null,















  history: []















}































export const CoinProvider = ({ children }) => {















  const { user, token } = useWebsiteAuth()















  const isLoggedIn = !!user && !!token































  const [wallet, setWallet] = useState({ ...DEFAULT_WALLET })















  const [hydrated, setHydrated] = useState(false)















  const [nextClaimInMs, setNextClaimInMs] = useState(0)































  const bcRef = useRef(null)















  const refreshingRef = useRef(false)
  const notificationFetchedRef = useRef(false)
































  const notifyPromotionUpdates = async () => {
    if (!isLoggedIn) return
    try {
      const res = await coinAPI.getNotifications()
      const notifications = res.data?.notifications || []
      notifications.forEach((notification) => {
        const message = notification.message || ''
        if (!message) return
        if (notification.variant === 'success') {
          toast.success(message)
        } else if (notification.variant === 'error') {
          toast.error(message)
        } else {
          toast(message)
        }
      })
    } catch (error) {
      console.error('取得宣傳購買通知失敗:', error)
    }
  }

  const refreshWallet = async () => {















    if (!isLoggedIn) {
      notificationFetchedRef.current = false















      setWallet({ ...DEFAULT_WALLET })















      setNextClaimInMs(0)















      setHydrated(true)















      return















    }















    if (refreshingRef.current) return















    refreshingRef.current = true















    try {















      const [wRes, hRes] = await Promise.all([















        coinAPI.getWallet(),















        coinAPI.getHistory(50)















      ])















      const w = wRes?.data?.wallet















      const h = hRes?.data?.history || []















      const serverNextMs = Number(wRes?.data?.nextClaimInMs) || 0















      















      const newWallet = {















        balance: Number(w?.balance) || 0,















        lastClaimAt: w?.lastClaimAt || null,















        history: h















      }















      















      setWallet(newWallet)















      setNextClaimInMs(serverNextMs)















      















      // 撱?蝯血隞???















      if (bcRef.current) {















        bcRef.current.postMessage({ 















          type: 'wallet:update', 















          wallet: newWallet,















          nextClaimInMs: serverNextMs















        })















      }















    } catch (e) {















      console.error('?瑟?Ｗ?憭望?:', e)















    } finally {















      setHydrated(true)















      refreshingRef.current = false















    }















  }































  // BroadcastChannel ?郊















  useEffect(() => {
    if (!isLoggedIn) {
      notificationFetchedRef.current = false
      return
    }
    if (!hydrated || notificationFetchedRef.current) return
    notificationFetchedRef.current = true
    notifyPromotionUpdates()
  }, [isLoggedIn, hydrated])

  useEffect(() => {















    const bc = new BroadcastChannel('crcrcoin')















    bcRef.current = bc















    bc.onmessage = (ev) => {















      const msg = ev?.data















      if (!msg || msg.type !== 'wallet:update') return















      setWallet(msg.wallet)















      setNextClaimInMs(msg.nextClaimInMs || 0)















    }















    return () => {















      try { bc.close() } catch {}















      bcRef.current = null















    }















  }, [])































  // ??頛















  useEffect(() => {















    setHydrated(false)















    setWallet({ ...DEFAULT_WALLET })















    setNextClaimInMs(0)















    refreshWallet()















  }, [isLoggedIn, user?.id])































  // ??航????















  useEffect(() => {















    const onVis = () => {















      if (document.visibilityState === 'visible') refreshWallet()















    }















    document.addEventListener('visibilitychange', onVis)















    return () => document.removeEventListener('visibilitychange', onVis)















  }, [isLoggedIn])































  const addCoins = async (amount, reason = '隞餃??') => {















    if (!isLoggedIn) return { success: false, error: '隢??餃' }















    const value = Math.max(0, Math.floor(Number(amount) || 0))















    if (value <= 0) return { success: false, error: '???⊥?' }















    try {















      const res = await coinAPI.earn(value, reason)















      const walletData = res?.data?.wallet















      















      // ?湔雿輻???刻????Ｗ??豢?嚗??閬??啁?風?脰???















      if (walletData) {















        try {















          // ?脣???啁?鈭斗?甇瑕















          const historyRes = await coinAPI.getHistory(50)















          const latestHistory = historyRes?.data?.history || []















          















          const newWallet = {















            balance: Number(walletData.balance) || 0,















            lastClaimAt: walletData.lastClaimAt || null,















            history: latestHistory















          }















          setWallet(newWallet)















          















          // 撱?蝯血隞???















          if (bcRef.current) {















            bcRef.current.postMessage({ 















              type: 'wallet:update', 















              wallet: newWallet,















              nextClaimInMs: nextClaimInMs















            })















          }















        } catch (historyError) {















          console.error('?脣?鈭斗?甇瑕憭望?:', historyError)















          // 憒??脣?甇瑕憭望?嚗撠?圈?憿?















          const newWallet = {















            balance: Number(walletData.balance) || 0,















            lastClaimAt: walletData.lastClaimAt || null,















            history: wallet.history || []















          }















          setWallet(newWallet)















        }















      } else {















        await refreshWallet()















      }















      















      return { success: true }















    } catch (e) {















      return { success: false, error: e?.response?.data?.error || '?馳憭望?' }















    }















  }































  const spendCoins = async (amount, reason = '瘨祥') => {















    if (!isLoggedIn) return { success: false, error: '隢??餃' }















    const value = Math.max(0, Math.floor(Number(amount) || 0))















    if (value <= 0) return { success: false, error: '???⊥?' }















    try {















      const res = await coinAPI.spend(value, reason)















      const walletData = res?.data?.wallet















      















      // ?湔雿輻???刻????Ｗ??豢?嚗??閬??啁?風?脰???















      if (walletData) {















        try {















          // ?脣???啁?鈭斗?甇瑕















          const historyRes = await coinAPI.getHistory(50)















          const latestHistory = historyRes?.data?.history || []















          















          const newWallet = {















            balance: Number(walletData.balance) || 0,















            lastClaimAt: walletData.lastClaimAt || null,















            history: latestHistory















          }















          setWallet(newWallet)















          















          // 撱?蝯血隞???















          if (bcRef.current) {















            bcRef.current.postMessage({ 















              type: 'wallet:update', 















              wallet: newWallet,















              nextClaimInMs: nextClaimInMs















            })















          }















        } catch (historyError) {















          console.error('?脣?鈭斗?甇瑕憭望?:', historyError)















          // 憒??脣?甇瑕憭望?嚗撠?圈?憿?















          const newWallet = {















            balance: Number(walletData.balance) || 0,















            lastClaimAt: walletData.lastClaimAt || null,















            history: wallet.history || []















          }















          setWallet(newWallet)















        }















      } else {















        await refreshWallet()















      }















      















      return { success: true }















    } catch (e) {















      return { success: false, error: e?.response?.data?.error || '??狡憭望?' }















    }















  }































  const claimDaily = async () => {















    if (!isLoggedIn) return { success: false, error: '隢??餃?蝪賢' }















    try {















      const res = await coinAPI.claimDaily()















      const amount = Number(res?.data?.amount) || 0















      const rawNextClaim = Number(res?.data?.nextClaimInMs)















      const nextWindowMs = Number.isFinite(rawNextClaim) ? rawNextClaim : 0















      const walletData = res?.data?.wallet















      















      // ?湔雿輻???刻????Ｗ??豢?嚗蒂?脣???啁?鈭斗?甇瑕















      if (walletData) {















        try {















          // ?脣???啁?鈭斗?甇瑕















          const historyRes = await coinAPI.getHistory(50)















          const latestHistory = historyRes?.data?.history || []















          















          const newWallet = {















            balance: Number(walletData.balance) || 0,















            lastClaimAt: walletData.lastClaimAt || null,















            history: latestHistory















          }















          setWallet(newWallet)















          setNextClaimInMs(nextWindowMs) // 依伺服器冷卻時間更新倒數















          















          // 撱?蝯血隞???















          if (bcRef.current) {















            bcRef.current.postMessage({ 















              type: 'wallet:update', 















              wallet: newWallet,















              nextClaimInMs: nextWindowMs















            })















          }















        } catch (historyError) {















          console.error('?脣?鈭斗?甇瑕憭望?:', historyError)















          // 憒??脣?甇瑕憭望?嚗撠?圈?憿?















          const newWallet = {















            balance: Number(walletData.balance) || 0,















            lastClaimAt: walletData.lastClaimAt || null,















            history: wallet.history || []















          }















          setWallet(newWallet)















          setNextClaimInMs(nextWindowMs)















        }















      } else {















        // 憒?瘝??Ｗ??豢?嚗?隤輻 refreshWallet















        setNextClaimInMs(nextWindowMs)















        await refreshWallet()















      }















      















      return { success: true, amount }















    } catch (e) {















      const serverNextMs = Number(e?.response?.data?.nextClaimInMs) || 0















      setNextClaimInMs(serverNextMs)















      return {















        success: false,















        error: e?.response?.data?.error || '尚未到簽到時間',















        nextClaimInMs: serverNextMs















      }















    }















  }































  const canClaimNow = isLoggedIn && hydrated && nextClaimInMs <= 0































  const value = {















    isLoggedIn,















    hydrated,















    balance: wallet.balance || 0,















    lastClaimAt: wallet.lastClaimAt,















    history: wallet.history || [],















    addCoins,















    spendCoins,















    claimDaily,















    canClaimNow,















    nextClaimInMs,















    refreshWallet















  }































  return (















    <CoinContext.Provider value={value}>{children}</CoinContext.Provider>















  )















}































export const useCoin = () => {















  const ctx = useContext(CoinContext)















  if (!ctx) throw new Error('useCoin must be used within CoinProvider')















  return ctx















}

































