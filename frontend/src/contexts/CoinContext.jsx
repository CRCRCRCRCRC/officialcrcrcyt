import { createContext, useContext, useEffect, useRef, useState } from 'react'
import toast from 'react-hot-toast'
















import { useWebsiteAuth } from './WebsiteAuthContext'















import { coinAPI } from '../services/api'































/**















 * CRCRCoin嚗??其?鞈港撩?嚗?















 * - ????敺撩???嚗?雿輻 localStorage 敹怠?















 * - ?舀憭???閬??? BroadcastChannel ?郊















 */































const CoinContext = createContext(null)































const DEFAULT_WALLET = {















  balance: 0,















  lastClaimAt: null,















  history: []















}































export const CoinProvider = ({ children }) => {















  const { user, token } = useWebsiteAuth()















  const isLoggedIn = !!user && !!token































  const [wallet, setWallet] = useState({ ...DEFAULT_WALLET })















  const [hydrated, setHydrated] = useState(false)















  const [nextClaimInMs, setNextClaimInMs] = useState(0)
  const [hasNewNotifications, setHasNewNotifications] = useState(false)































  const bcRef = useRef(null)















  const refreshingRef = useRef(false)
  const notificationFetchedRef = useRef(false)
































  const notifyPromotionUpdates = async () => {
    if (!isLoggedIn) return
    try {
      const res = await coinAPI.getNotifications('new')
      const notifications = res.data?.notifications || []
      if (notifications.length > 0) {
        setHasNewNotifications(true)
      }
      notifications.forEach((notification) => {
        const message = notification.message || ''
        if (!message) return
        if (notification.variant === 'success') {
          toast.success(message)
        } else if (notification.variant === 'error') {
          toast.error(message)
        } else {
          toast(message)
        }
      })
    } catch (error) {
      console.error('取得宣傳購買通知失敗:', error)
    }
  }

  const refreshWallet = async () => {
    if (!isLoggedIn) {
      notificationFetchedRef.current = false
      setHasNewNotifications(false)
      setWallet({ ...DEFAULT_WALLET })
      setNextClaimInMs(0)
      setHydrated(true)
      return
    }

    if (refreshingRef.current) return
    refreshingRef.current = true

    try {
      const wRes = await coinAPI.getWallet()
      const walletData = wRes?.data?.wallet
      const serverNextMs = Number(wRes?.data?.nextClaimInMs) || 0

      const baseWallet = {
        balance: Number(walletData?.balance) || 0,
        lastClaimAt: walletData?.lastClaimAt || null,
        history: wallet.history || []
      }

      setWallet(baseWallet)
      setNextClaimInMs(serverNextMs)
      setHydrated(true)

      if (bcRef.current) {
        bcRef.current.postMessage({
          type: 'wallet:update',
          wallet: baseWallet,
          nextClaimInMs: serverNextMs
        })
      }

      // Background history fetch to avoid blocking UI
      coinAPI.getHistory(50)
        .then((hRes) => {
          const history = hRes?.data?.history || []
          const merged = { ...baseWallet, history }
          setWallet(merged)
          if (bcRef.current) {
            bcRef.current.postMessage({
              type: 'wallet:update',
              wallet: merged,
              nextClaimInMs: serverNextMs
            })
          }
        })
        .catch((err) => {
          console.error('Background history fetch failed:', err)
        })
    } catch (e) {
      console.error('Wallet fetch failed:', e)
      setHydrated(true)
    } finally {
      refreshingRef.current = false
    }
  }

// BroadcastChannel ?郊















  useEffect(() => {
    if (!isLoggedIn) {
      notificationFetchedRef.current = false
      return
    }
    if (!hydrated || notificationFetchedRef.current) return
    notificationFetchedRef.current = true
    notifyPromotionUpdates()
  }, [isLoggedIn, hydrated])

  useEffect(() => {















    const bc = new BroadcastChannel('crcrcoin')















    bcRef.current = bc















    bc.onmessage = (ev) => {















      const msg = ev?.data















      if (!msg || msg.type !== 'wallet:update') return















      setWallet(msg.wallet)















      setNextClaimInMs(msg.nextClaimInMs || 0)















    }















    return () => {















      try { bc.close() } catch {}















      bcRef.current = null















    }















  }, [])































  // ??頛















  useEffect(() => {















    setHydrated(false)















    setWallet({ ...DEFAULT_WALLET })















    setNextClaimInMs(0)















    refreshWallet()















  }, [isLoggedIn, user?.id])































  // ??航????















  useEffect(() => {















    const onVis = () => {















      if (document.visibilityState === 'visible') refreshWallet()















    }















    document.addEventListener('visibilitychange', onVis)















    return () => document.removeEventListener('visibilitychange', onVis)















  }, [isLoggedIn])































  const addCoins = async (amount, reason = '隞餃??') => {















    if (!isLoggedIn) return { success: false, error: '隢??餃' }















    const value = Math.max(0, Math.floor(Number(amount) || 0))















    if (value <= 0) return { success: false, error: '???⊥?' }















    try {















      const res = await coinAPI.earn(value, reason)















      const walletData = res?.data?.wallet















      















      // ?湔雿輻???刻????Ｗ??豢?嚗??閬??啁?風?脰???















      if (walletData) {















        try {















          // ?脣???啁?鈭斗?甇瑕















          const historyRes = await coinAPI.getHistory(50)















          const latestHistory = historyRes?.data?.history || []















          















          const newWallet = {















            balance: Number(walletData.balance) || 0,















            lastClaimAt: walletData.lastClaimAt || null,















            history: latestHistory















          }















          setWallet(newWallet)















          















          // 撱?蝯血隞???















          if (bcRef.current) {















            bcRef.current.postMessage({ 















              type: 'wallet:update', 















              wallet: newWallet,















              nextClaimInMs: nextClaimInMs















            })















          }















        } catch (historyError) {















          console.error('?脣?鈭斗?甇瑕憭望?:', historyError)















          // 憒??脣?甇瑕憭望?嚗撠?圈?憿?















          const newWallet = {















            balance: Number(walletData.balance) || 0,















            lastClaimAt: walletData.lastClaimAt || null,















            history: wallet.history || []















          }















          setWallet(newWallet)















        }















      } else {















        await refreshWallet()















      }















      















      return { success: true }















    } catch (e) {















      return { success: false, error: e?.response?.data?.error || '?馳憭望?' }















    }















  }































  const spendCoins = async (amount, reason = '瘨祥') => {















    if (!isLoggedIn) return { success: false, error: '隢??餃' }















    const value = Math.max(0, Math.floor(Number(amount) || 0))















    if (value <= 0) return { success: false, error: '???⊥?' }















    try {















      const res = await coinAPI.spend(value, reason)















      const walletData = res?.data?.wallet















      















      // ?湔雿輻???刻????Ｗ??豢?嚗??閬??啁?風?脰???















      if (walletData) {















        try {















          // ?脣???啁?鈭斗?甇瑕















          const historyRes = await coinAPI.getHistory(50)















          const latestHistory = historyRes?.data?.history || []















          















          const newWallet = {















            balance: Number(walletData.balance) || 0,















            lastClaimAt: walletData.lastClaimAt || null,















            history: latestHistory















          }















          setWallet(newWallet)















          















          // 撱?蝯血隞???















          if (bcRef.current) {















            bcRef.current.postMessage({ 















              type: 'wallet:update', 















              wallet: newWallet,















              nextClaimInMs: nextClaimInMs















            })















          }















        } catch (historyError) {















          console.error('?脣?鈭斗?甇瑕憭望?:', historyError)















          // 憒??脣?甇瑕憭望?嚗撠?圈?憿?















          const newWallet = {















            balance: Number(walletData.balance) || 0,















            lastClaimAt: walletData.lastClaimAt || null,















            history: wallet.history || []















          }















          setWallet(newWallet)















        }















      } else {















        await refreshWallet()















      }















      















      return { success: true }















    } catch (e) {















      return { success: false, error: e?.response?.data?.error || '??狡憭望?' }















    }















  }































  const claimDaily = async () => {
    if (!isLoggedIn) return { success: false, error: 'Login required' }

    try {
      const res = await coinAPI.claimDaily()
      const amount = Number(res?.data?.amount) || 0
      const rawNextClaim = Number(res?.data?.nextClaimInMs)
      const nextWindowMs = Number.isFinite(rawNextClaim) ? rawNextClaim : 0
      const walletData = res?.data?.wallet

      if (walletData) {
        const baseWallet = {
          balance: Number(walletData.balance) || 0,
          lastClaimAt: walletData.lastClaimAt || null,
          history: wallet.history || []
        }
        setWallet(baseWallet)
        setNextClaimInMs(nextWindowMs)

        if (bcRef.current) {
          bcRef.current.postMessage({
            type: 'wallet:update',
            wallet: baseWallet,
            nextClaimInMs: nextWindowMs
          })
        }

        // Background fetch history without blocking claim response
        coinAPI.getHistory(50)
          .then((historyRes) => {
            const latestHistory = historyRes?.data?.history || []
            const merged = { ...baseWallet, history: latestHistory }
            setWallet(merged)
            if (bcRef.current) {
              bcRef.current.postMessage({
                type: 'wallet:update',
                wallet: merged,
                nextClaimInMs: nextWindowMs
              })
            }
          })
          .catch((historyError) => {
            console.error('Background history fetch failed:', historyError)
          })
      } else {
        setNextClaimInMs(nextWindowMs)
        await refreshWallet()
      }

      return { success: true, amount }
    } catch (e) {
      const serverNextMs = Number(e?.response?.data?.nextClaimInMs) || 0
      setNextClaimInMs(serverNextMs)
      return {
        success: false,
        error: e?.response?.data?.error || 'Not ready to claim yet',
        nextClaimInMs: serverNextMs
      }
    }
  }































  return (















    <CoinContext.Provider value={value}>{children}</CoinContext.Provider>















  )















}































export const useCoin = () => {















  const ctx = useContext(CoinContext)















  if (!ctx) throw new Error('useCoin must be used within CoinProvider')















  return ctx















}

































